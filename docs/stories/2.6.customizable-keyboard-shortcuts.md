# Story 2.6: Customizable Keyboard Shortcuts

## Status
Approved

## Story
**As a** music producer who has developed my own workflow preferences,
**I want** to customize keyboard shortcuts to match my personal workflow and muscle memory from other DAWs,
**so that** I can work more efficiently with shortcuts that feel natural to me and don't conflict with my system shortcuts or other applications.

## Acceptance Criteria

1. **Shortcut Customization Interface** - Users can modify keyboard shortcuts through the Settings dialog
   - Given the user opens the Keyboard tab in Settings
   - When the user clicks on any shortcut field, it enters "recording mode" (NOT a text input field)
   - And the user must press the actual key combination they want (no typing allowed)
   - And the system captures the real key presses and automatically formats them correctly
   - And the interface shows real-time feedback showing exactly what keys are being detected
   - And invalid or conflicting shortcuts show clear error messages
   - And users can reset individual shortcuts to defaults with a reset button per shortcut

2. **Conflict Detection and Resolution** - System prevents and resolves shortcut conflicts
   - Given the user attempts to assign a shortcut that's already in use
   - When the conflict is detected, the system shows which existing shortcut would be affected
   - And the user can choose to swap the shortcuts, override the existing one, or cancel the change
   - And system shortcuts (like Cmd+Q on macOS) are detected and warned against
   - And the conflict resolution dialog provides clear options for how to proceed

3. **Shortcut Recording Interface** - Key capture system (NO text input)
   - Given the user clicks on a shortcut field to edit it
   - When the field enters recording mode, it shows "Press keys..." and captures actual key presses
   - And NO text input is allowed - users cannot type characters or strings
   - And any key combination pressed is immediately detected and displayed with proper formatting
   - And modifier keys (Ctrl, Alt, Shift, Cmd) are properly detected and formatted automatically
   - And special keys (Space, Enter, Arrow keys, etc.) are properly recognized and displayed with correct names
   - And the recording can be cancelled with Escape key or clicking outside the field
   - And the system prevents invalid combinations (like modifier-only shortcuts) from being recorded

4. **Validation and Feedback** - Comprehensive input validation with user guidance
   - Given the user presses keys to record a new shortcut combination
   - When the combination is invalid (empty, too complex, or unsupported), clear error messages explain why
   - And when the combination is valid but conflicts with existing shortcuts, specific conflict details are shown
   - And when the combination uses system shortcuts, appropriate warnings are displayed
   - And validation happens in real-time as the user presses keys during recording mode

5. **Persistence and Export/Import** - Custom shortcuts are saved and can be shared
   - Given the user has customized their keyboard shortcuts
   - When the application is restarted, all custom shortcuts are preserved
   - And users can export their shortcut configuration to a file
   - And users can import shortcut configurations from files
   - And imported configurations are validated and conflicts resolved before application
   - And there's a "Reset All to Defaults" option that restores factory shortcuts

## Tasks / Subtasks

- [ ] **Enhanced Keyboard Settings UI** (AC: 1, 3)
  - [ ] **CRITICAL: NO text input fields** - Convert read-only display to clickable recording buttons
  - [ ] **CRITICAL: Key capture only** - Implement recording mode that captures actual key presses (not typing)
  - [ ] **CRITICAL: No typing allowed** - Users must press the actual key combination they want
  - [ ] Implement per-shortcut reset buttons
  - [ ] Add real-time key combination capture and display with proper formatting
  - [ ] Create intuitive visual states (recording, valid, invalid, conflicted)

- [ ] **Advanced Conflict Detection System** (AC: 2, 4)
  - [ ] Extend KeyboardSettings validation to detect all types of conflicts
  - [ ] Add system shortcut detection for each platform (macOS, Windows, Linux)
  - [ ] Create conflict resolution dialog with swap/override/cancel options
  - [ ] Implement real-time conflict checking as user presses keys during recording
  - [ ] Add severity levels (error, warning, info) for different conflict types

- [ ] **Shortcut Recording Engine** (AC: 3)
  - [ ] Implement key combination capture system using egui input events
  - [ ] Add proper modifier key detection and formatting
  - [ ] Handle special keys (arrows, function keys, etc.) with proper names
  - [ ] Create cancellation mechanisms (Escape, click outside)
  - [ ] Ensure cross-platform consistency in key capture and naming

- [ ] **Configuration Management** (AC: 5)
  - [ ] Extend settings system to support custom shortcut persistence
  - [ ] Implement export functionality to save shortcuts to JSON/TOML file
  - [ ] Add import functionality with validation and conflict resolution
  - [ ] Create "Reset All to Defaults" with confirmation dialog
  - [ ] Add backup/restore mechanism for shortcut configurations

- [ ] **Enhanced Validation Framework** (AC: 4)
  - [ ] Extend KeyboardSettings validation with detailed error categorization
  - [ ] Add real-time validation feedback in the UI
  - [ ] Create user-friendly error messages with suggested fixes
  - [ ] Implement warning system for potentially problematic shortcuts
  - [ ] Add validation for platform-specific constraints and limitations

- [ ] **Testing and Documentation** (AC: 1, 2, 3, 4, 5)
  - [ ] Create unit tests for shortcut recording and validation logic
  - [ ] Add integration tests for conflict detection and resolution
  - [ ] Test import/export functionality with various file formats
  - [ ] Create cross-platform tests for system shortcut detection
  - [ ] Test shortcut persistence across application restarts
  - [ ] Add user documentation for customizing shortcuts

## Dev Notes

### Foundation from Story 2.5

**Excellent Infrastructure in Place**:
- **KeyboardSettings structure** with comprehensive validation and parsing ✅
- **Cross-platform modifier handling** (Cmd vs Ctrl) already implemented ✅
- **Settings persistence** through existing auto-save mechanism ✅
- **29 comprehensive tests** covering parsing, validation, and cross-platform behavior ✅
- **Menu integration** showing shortcuts already working ✅
- **Key parsing logic** in `KeyboardSettings::parse_shortcut()` ✅
- **Key matching logic** in `KeyboardSettings::matches_shortcut()` ✅

**CRITICAL: Reuse Existing Infrastructure - Don't Reinvent**:
```rust
// ✅ LEVERAGE Story 2.5's parsing - already handles all keys correctly
if let Some((key, modifiers)) = KeyboardSettings::parse_shortcut(&new_shortcut) {
    // Valid combination - Story 2.5 already validated the format
}

// ✅ LEVERAGE Story 2.5's formatting - already handles platform differences  
let display_shortcut = format_shortcut_for_display(&recorded_shortcut);

// ✅ LEVERAGE Story 2.5's validation - already prevents duplicates
keyboard_settings.validate()?; // Will catch conflicts

// ✅ LEVERAGE Story 2.5's persistence - already saves to settings file
app_settings.keyboard = updated_keyboard_settings;
app_settings.auto_save()?; // Story 2.5's mechanism
```

**Key Extension Points**:
```rust
// Existing KeyboardSettings already has validation - extend for conflicts
impl KeyboardSettings {
    pub fn validate(&self) -> Result<()> { /* Extend for system conflicts */ }
    pub fn detect_conflicts(&self) -> Vec<ShortcutConflict> { /* New method */ }
    pub fn resolve_conflict(&mut self, resolution: ConflictResolution) -> Result<()> { /* New */ }
    
    // New methods building on existing foundation
    pub fn is_system_shortcut(shortcut: &str) -> bool { /* New */ }
    pub fn get_conflicting_action(&self, shortcut: &str) -> Option<String> { /* New */ }
}
```

**Integration Points with Story 2.5**:
- **Reuse app.rs keyboard handling** - same event capture pattern
- **Extend settings_dialog.rs** - convert read-only display to recording mode
- **Reuse settings.rs validation** - extend existing conflict detection
- **Maintain test patterns** - follow same testing approach as the 29 existing tests

### CRITICAL: Key Capture Implementation - NO TEXT INPUT

**❌ WRONG APPROACH (like Story 2.4)**: 
```rust
// DON'T DO THIS - allows users to type arbitrary text
if ui.text_edit_singleline(&mut shortcut).changed() {
    // User can type "asdf" or invalid combinations
}
```

**✅ CORRECT APPROACH**: Key Recording Mode
```rust
fn show_shortcut_recorder(&mut self, ui: &mut egui::Ui, 
                         current_shortcut: &str,
                         shortcut_id: &str) -> Option<String> {
    if self.recording_state.is_recording_for(shortcut_id) {
        // Show "Press keys..." and capture actual key events
        ui.colored_label(egui::Color32::YELLOW, "Press keys...");
        
        // Capture key events from egui context - NO TEXT INPUT
        ui.ctx().input(|i| {
            for event in &i.events {
                if let egui::Event::Key { key, pressed: true, modifiers, .. } = event {
                    let recorded = format_key_combination(*key, modifiers);
                    return Some(recorded);
                }
            }
            None
        })
    } else {
        // Show current shortcut as a clickable button
        if ui.button(current_shortcut).clicked() {
            self.recording_state.start_recording(shortcut_id);
        }
        None
    }
}
```

### UI Enhancement Requirements

**Current State**: Read-only display in `settings_dialog.rs:758-884`
```rust
fn show_keyboard_settings(&mut self, ui: &mut egui::Ui) -> bool {
    // Currently: ui.monospace(&keyboard.play_pause);
    // Enhancement: Replace with key recording buttons (NOT text fields)
}
```

### Conflict Detection Architecture

**System Shortcut Database**:
```rust
pub struct SystemShortcuts {
    macos: Vec<String>,      // Cmd+Q, Cmd+W, Cmd+M, etc.
    windows: Vec<String>,    // Alt+F4, Ctrl+Alt+Del, etc.  
    linux: Vec<String>,      // Ctrl+Alt+T, Super+L, etc.
}

impl SystemShortcuts {
    pub fn is_system_shortcut(shortcut: &str) -> ShortcutWarning {
        // Platform-specific system shortcut detection
    }
}
```

**Conflict Types and Resolution**:
```rust
#[derive(Debug, Clone)]
pub enum ConflictType {
    ApplicationDuplicate { existing_action: String },
    SystemShortcut { system_function: String, severity: ConflictSeverity },
    PlatformRecommendation { recommendation: String },
}

#[derive(Debug, Clone)]
pub enum ConflictSeverity {
    Error,      // Cannot assign (e.g., empty shortcut)
    Warning,    // Can assign but not recommended (e.g., Cmd+Q)
    Info,       // Notable but fine (e.g., non-standard but valid)
}

pub enum ConflictResolution {
    SwapShortcuts { from: String, to: String },
    OverrideExisting { action: String },
    Cancel,
}
```

### Shortcut Recording Implementation

**CRITICAL: Key Event Capture (Building on Story 2.5's Foundation)**:
```rust
// Leverage existing keyboard handling from Story 2.5
// In settings_dialog.rs, extend the keyboard settings UI

impl SettingsDialog {
    fn show_keyboard_settings(&mut self, ui: &mut egui::Ui) -> bool {
        // For each shortcut, show recorder button instead of text field
        ui.ctx().input(|i| {
            if self.recording_state.active {
                // Capture key events during recording mode
                for event in &i.events {
                    if let egui::Event::Key { key, pressed: true, modifiers, .. } = event {
                        // Use existing KeyboardSettings::parse_shortcut validation
                        let combo = self.format_key_combination(*key, modifiers);
                        self.handle_recorded_shortcut(combo);
                    }
                }
            }
        });
    }
    
    fn handle_recorded_shortcut(&mut self, shortcut: String) {
        // Validate using existing Story 2.5 infrastructure
        if let Some((key, modifiers)) = KeyboardSettings::parse_shortcut(&shortcut) {
            // Valid shortcut - check for conflicts and apply
            self.apply_shortcut_change(shortcut);
        } else {
            // Invalid - show error without allowing the change
            self.show_validation_error("Invalid key combination");
        }
    }
}
```

**Recording Mode State Management**:
```rust
#[derive(Default)]
pub struct ShortcutRecording {
    pub active: bool,
    pub recording_for: Option<String>,  // Which shortcut is being recorded
    pub timeout: Option<std::time::Instant>,  // Auto-cancel after timeout
}

impl ShortcutRecording {
    pub fn start_recording(&mut self, shortcut_id: String) {
        self.active = true;
        self.recording_for = Some(shortcut_id);
        self.timeout = Some(std::time::Instant::now() + std::time::Duration::from_secs(10));
    }
    
    pub fn is_recording_for(&self, shortcut_id: &str) -> bool {
        self.active && self.recording_for.as_ref() == Some(&shortcut_id.to_string())
    }
    
    pub fn cancel_recording(&mut self) {
        self.active = false;
        self.recording_for = None;
        self.timeout = None;
    }
    
    pub fn check_timeout(&mut self) -> bool {
        if let Some(timeout) = self.timeout {
            if std::time::Instant::now() > timeout {
                self.cancel_recording();
                return true;
            }
        }
        false
    }
}
```

**Key Combination Formatting (Reuse Story 2.5 Logic)**:
```rust
impl SettingsDialog {
    fn format_key_combination(&self, key: egui::Key, modifiers: &egui::Modifiers) -> String {
        // Reuse the excellent formatting logic from Story 2.5
        // This ensures consistency with existing shortcut display
        let mut parts = Vec::new();
        
        // Platform-specific modifier ordering
        if modifiers.ctrl { parts.push("Ctrl".to_string()); }
        if modifiers.alt { parts.push("Alt".to_string()); }
        if modifiers.shift { parts.push("Shift".to_string()); }
        if modifiers.mac_cmd { parts.push("Cmd".to_string()); }
        
        // Add the main key using existing key name mapping
        parts.push(self.key_to_display_name(key));
        
        parts.join("+")
    }
    
    fn key_to_display_name(&self, key: egui::Key) -> String {
        // Reuse existing logic from KeyboardSettings::parse_shortcut
        // Ensures consistency between recording and parsing
        match key {
            egui::Key::Space => "Space".to_string(),
            egui::Key::Enter => "Enter".to_string(),
            egui::Key::ArrowLeft => "Left".to_string(),
            egui::Key::ArrowRight => "Right".to_string(),
            // ... etc (leverage existing mapping)
            _ => format!("{:?}", key)  // Fallback
        }
    }
}
```

### File Export/Import Architecture

**Configuration File Format**:
```json
{
  "version": "2.6.0",
  "platform": "macos",
  "shortcuts": {
    "transport": {
      "play_pause": "Space",
      "return_to_start": "Enter",
      "stop_escape": "Escape"
    },
    "timeline": {
      "step_back": "Left",
      "step_forward": "Right",
      "jump_back": "Shift+Left",
      "jump_forward": "Shift+Right",
      "start": "Home",
      "end": "End"
    },
    "application": {
      "new_project": "Cmd+N",
      "open_project": "Cmd+O",
      "save_project": "Cmd+S",
      "save_project_as": "Cmd+Shift+S",
      "open_settings": "Cmd+,"
    },
    "pattern": {
      "clear": "Delete",
      "select_all": "Cmd+A"
    }
  },
  "metadata": {
    "created": "2025-08-07T10:30:00Z",
    "description": "Custom shortcuts for Pro Tools workflow"
  }
}
```

### Cross-Platform Considerations

**Platform-Specific Validation**:
- **macOS**: Detect Cmd+Q, Cmd+H, Cmd+M, Option+Cmd+Esc, etc.
- **Windows**: Detect Alt+F4, Ctrl+Alt+Del, Win+L, Alt+Tab, etc.
- **Linux**: Detect Ctrl+Alt+T, Super+L, Alt+F2, etc.

**Import Compatibility**:
- Convert between platforms (Cmd ↔ Ctrl) when importing configurations
- Validate platform compatibility and warn about unsupported shortcuts
- Provide automatic conversion suggestions

### Integration with Existing Pattern Grid

**Future Compatibility**: 
The shortcut recording system should be designed to easily integrate with pattern grid shortcuts when that component is refactored (addressing the limitation noted in Story 2.5).

### Performance Considerations

**Efficient Conflict Checking**:
- Cache system shortcut databases for fast lookup
- Use HashMap for O(1) conflict detection within application shortcuts
- Lazy load platform-specific system shortcut data
- Debounce real-time validation to avoid excessive checking

### User Experience Design

**Recording UI States** (NO text input mode):
```rust
fn show_shortcut_button(&mut self, ui: &mut egui::Ui, shortcut: &str, shortcut_id: &str) -> bool {
    if self.recording_state.is_recording_for(shortcut_id) {
        // Recording mode - show pulsing/highlighted state
        let recording_response = ui.add(
            egui::Button::new("Press keys...")
                .fill(egui::Color32::from_rgb(255, 255, 0))  // Yellow highlight
                .text_color(egui::Color32::BLACK)
        );
        
        // Handle escape to cancel
        if ui.input(|i| i.key_pressed(egui::Key::Escape)) {
            self.recording_state.cancel_recording();
        }
        
        // Handle timeout
        if self.recording_state.check_timeout() {
            // Show timeout message briefly
        }
        
        false
    } else {
        // Normal mode - clickable shortcut button
        let button_text = if shortcut.is_empty() { "Click to set" } else { shortcut };
        ui.button(button_text).clicked()
    }
}
```

**Progressive Disclosure**:
1. **Basic Mode**: Click button → Press keys → Done (no typing allowed)
2. **Advanced Mode**: Conflict resolution dialogs when conflicts detected
3. **Expert Mode**: Import/export and batch operations

**Visual Feedback States**:
- **Default**: Normal shortcut button display
- **Recording**: Yellow highlighted button with "Press keys..." text
- **Valid**: Green checkmark icon next to shortcut after successful change
- **Invalid**: Red X icon with error tooltip (but change is blocked)
- **Conflicted**: Yellow warning icon with conflict details dialog
- **System Warning**: Orange caution icon with system shortcut explanation
- **Timeout**: Brief red flash and return to normal state

## Testing

### Unit Tests Required

**Shortcut Recording Tests**:
- Test key combination capture with various modifier combinations
- Test special key handling (arrows, function keys, etc.)
- Test recording cancellation and timeout scenarios
- Test cross-platform key name formatting and parsing

**Conflict Detection Tests**:
- Test application shortcut duplicate detection
- Test system shortcut detection for each platform
- Test conflict severity classification (error, warning, info)
- Test conflict resolution logic (swap, override, cancel)

**Configuration Management Tests**:
- Test export functionality with various shortcut configurations
- Test import validation and conflict resolution during import
- Test persistence of custom shortcuts across application restarts
- Test "Reset All to Defaults" functionality

### Integration Tests

**End-to-End Workflow Tests**:
- Test complete shortcut customization workflow from settings dialog
- Test shortcut recording → validation → persistence → usage cycle
- Test conflict detection → resolution → application workflow
- Test export → import → validation workflow across different configurations

**Cross-Platform Compatibility Tests**:
- Test system shortcut detection on different platforms
- Test shortcut format conversion during import/export
- Test platform-specific validation rules and warnings

### User Experience Tests

**Usability Testing Scenarios**:
- Test shortcut recording discoverability and intuitiveness  
- Test conflict resolution dialog clarity and effectiveness
- Test error message comprehension and actionability
- Test import/export workflow for sharing configurations

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-07 | 1.0 | Initial story creation for Customizable Keyboard Shortcuts | Quinn (qa) |